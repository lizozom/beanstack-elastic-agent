"""
Generate Quarterly Business Review (QBR) reports for BeanStack coffee chain.

Numeric data is deterministic. Narrative fields (labor_manager_narrative,
inventory_manager_narrative, notes) are generated by Claude Haiku using
full branch/staff/seasonal context — kept short and relevant.

Revenue tiers:
  - Top cities (NYC, SF): $150-250k/month base
  - Other cities: $110-120k/month base
  - Super peak (busiest season + super performer): up to $320k/month

Performance distribution:
  - 85% average for their location
  - 10% under-performing
  - 5% super-performing

Quarters: Q1-2023 through Q4-2025 (3 years, 12 quarters)
Submission: ~1 month after quarter end ±3 days

Usage:
    uv run python scripts/data_generation/quarterly_reports.py [branch-001 branch-002 ...]
"""

import calendar
import hashlib
import json
import random
import sys
from collections import Counter
from datetime import datetime, timedelta
from pathlib import Path

import anthropic
from dotenv import load_dotenv

load_dotenv()

random.seed(42)

PROJECT_ROOT = Path(__file__).resolve().parent.parent.parent
DATA_DIR = PROJECT_ROOT / "data" / "generated"

# Quarter definitions: (quarter_label, quarter_start, quarter_end, submission_base)
QUARTERS = []
for year in range(2023, 2026):
    for q, (sm, em, sub_m, sub_d) in enumerate(
        [
            (1, 3, 4, 3),   # Q1: Jan-Mar, submit ~Apr 3
            (4, 6, 7, 3),   # Q2: Apr-Jun, submit ~Jul 3
            (7, 9, 10, 3),  # Q3: Jul-Sep, submit ~Oct 3
            (10, 12, 1, 3), # Q4: Oct-Dec, submit ~Jan 3 (next year)
        ],
        start=1,
    ):
        q_start = datetime(year, sm, 1)
        last_day = calendar.monthrange(year, em)[1]
        q_end = datetime(year, em, last_day)
        sub_year = year + 1 if em == 12 else year
        submission_base = datetime(sub_year, sub_m, sub_d)
        QUARTERS.append((f"Q{q}-{year}", q_start, q_end, submission_base))

SEASON_LABELS = {1: "winter", 2: "spring", 3: "summer", 4: "fall/holiday"}

# Top-tier cities get higher revenue
TOP_CITIES = {"New York", "San Francisco"}

# Seasonal multipliers by quarter (Q1-Q4)
SEASONAL_MULT = {
    1: 0.88,  # Q1: post-holiday slump, winter
    2: 1.00,  # Q2: spring, normalizing
    3: 1.08,  # Q3: summer iced drinks surge
    4: 1.12,  # Q4: holiday rush, peppermint season
}

# Size multipliers
SIZE_MULT = {"small": 0.70, "medium": 1.00, "large": 1.35}

# Narrative-driven adjustments
NARRATIVE_EQUIPMENT_ISSUES = {
    "equipment_cursed": (4, 8),
    "haunted_building": (2, 5),
    "renovation_saga": (3, 6),
}
NARRATIVE_HIGH_TRAFFIC = {
    "transit_hub", "tiktok_famous", "tourist_trap", "sports_bar_neighbor",
    "college_campus", "medical_complex",
}
NARRATIVE_SATISFACTION_PENALTY = {
    "overperformer_disliked_manager": -0.3,
    "gentrification_tension": -0.15,
    "rival_coffee_shop": -0.1,
}
NARRATIVE_SATISFACTION_BONUS = {
    "dog_friendly": 0.15,
    "eco_warrior": 0.1,
    "steady_boring": 0.2,
    "aspiring_artists": 0.05,
}

TOP_SELLING_ITEMS_POOL = {
    1: [  # Q1 winter
        "House Blend Drip", "Vanilla Latte", "Hot Chocolate",
        "Chai Tea Latte", "Peppermint Mocha", "Cappuccino",
        "Americano", "Caramel Macchiato", "Oat Milk Latte",
        "Matcha Latte", "Croissant", "Blueberry Muffin",
    ],
    2: [  # Q2 spring
        "Iced Americano", "Vanilla Latte", "Cold Brew",
        "Matcha Latte", "House Blend Drip", "Cappuccino",
        "Lavender Latte", "Oat Milk Latte", "Avocado Toast",
        "Banana Bread", "Iced Chai", "Green Smoothie",
    ],
    3: [  # Q3 summer
        "Cold Brew", "Iced Vanilla Latte", "Mango Smoothie",
        "Iced Matcha", "Frappuccino", "Iced Caramel Macchiato",
        "Acai Bowl", "Iced Oat Milk Latte", "Lemonade",
        "Berry Smoothie", "Iced Americano", "Coconut Cold Brew",
    ],
    4: [  # Q4 fall/holiday
        "Pumpkin Spice Latte", "House Blend Drip", "Caramel Macchiato",
        "Peppermint Mocha", "Gingerbread Latte", "Hot Chocolate",
        "Chai Tea Latte", "Eggnog Latte", "Apple Cider",
        "Maple Pecan Latte", "Croissant", "Pumpkin Bread",
    ],
}


def deterministic_hash(seed_str: str) -> float:
    """Return a deterministic float [0, 1) from a string seed."""
    h = int(hashlib.sha256(seed_str.encode()).hexdigest(), 16)
    return (h % 10000) / 10000.0


def assign_performance_tier(branch_id: str) -> str:
    """Assign a stable performance tier: 85% average, 10% under, 5% super."""
    val = deterministic_hash(f"perf-tier-{branch_id}")
    if val < 0.05:
        return "super"
    elif val < 0.15:
        return "under"
    return "average"


def get_quarter_num(period: str) -> int:
    """Extract quarter number from period like 'Q3-2025'."""
    return int(period[1])


def jitter(base: float, pct: float, seed: str) -> float:
    """Add deterministic jitter to a value."""
    h = deterministic_hash(seed)
    return base * (1 + pct * (2 * h - 1))


def generate_narratives_with_llm(
    client: anthropic.Anthropic,
    branch: dict,
    manager: dict,
    narrative: dict,
    period: str,
    qnum: int,
    tier: str,
    revenue: float,
    labor_cost_pct: float,
    waste_pct: float,
    top_items: list[str],
    equipment_issues: int,
    turnover: list[dict],
    employee_count: int,
    satisfaction: float,
) -> dict:
    """Generate the 3 narrative fields via Claude Haiku. Returns dict with keys:
    labor_manager_narrative, inventory_manager_narrative, notes."""

    season = SEASON_LABELS[qnum]
    turnover_names = [t["name"].split()[0] for t in turnover]
    narrative_desc = narrative.get("narrative_description", "Normal operations")
    narrative_themes = ", ".join(narrative.get("narrative_themes", []))

    narrative_tone = narrative.get("narrative_tone", "matter-of-fact")

    prompt = f"""Write 3 short narrative fields for a coffee shop quarterly business review (QBR) form.
The manager is filling these out quickly — keep each one 1-2 sentences, direct and specific to the data below.

<numbers>
Branch: {branch["name"]} ({branch["city"]}, {branch["state"]}) — {branch["size"]} location
Manager: {manager["name"]}
Period: {period} ({season})
Performance tier: {tier}
Revenue: ${revenue:,.0f} (quarterly)
Labor cost: {labor_cost_pct}% of revenue | {employee_count} employees | {"over budget" if labor_cost_pct > 35 else "on track"}
Staff who left this quarter: {", ".join(turnover_names) if turnover_names else "none"}
Inventory waste: {waste_pct}% | Top sellers: {", ".join(top_items[:3])}
Equipment issues: {equipment_issues}
Customer satisfaction: {satisfaction}/5.0
</numbers>

<branch_narrative>
This branch's ongoing story: {narrative_desc}
Recurring themes to reference: {narrative_themes}
Manager's writing tone: {narrative_tone}
</branch_narrative>

Return ONLY valid JSON (no markdown, no explanation):
{{"labor_manager_narrative": "...", "inventory_manager_narrative": "...", "notes": "..."}}

Rules:
- labor_manager_narrative: About staffing/labor this quarter. Mention specific staff names if someone left. 1-2 sentences max.
- inventory_manager_narrative: About inventory/waste/top items. 1-2 sentences max.
- notes: General quarter observations. MUST reference 1-2 of the recurring themes from <branch_narrative> — these are real things happening at this branch, not optional flavor.
- Be specific to the numbers. Don't be generic.
- Match the manager's writing tone from <branch_narrative>.
- Write like a busy manager, not a report. Casual american english."""

    message = client.messages.create(
        model="claude-haiku-4-5-20251001",
        max_tokens=300,
        messages=[{"role": "user", "content": prompt}],
    )

    raw = message.content[0].text.strip()
    # Strip markdown fences if present
    if raw.startswith("```"):
        raw = raw.split("\n", 1)[1]
        if raw.endswith("```"):
            raw = raw[: raw.rfind("```")]
        raw = raw.strip()

    try:
        return json.loads(raw)
    except json.JSONDecodeError:
        # Fallback to template narratives
        return {
            "labor_manager_narrative": f"Labor at {labor_cost_pct}% of revenue. {f'{turnover_names[0]} left this quarter.' if turnover_names else 'Team was stable.'}",
            "inventory_manager_narrative": f"Waste at {waste_pct}%. {top_items[0]} and {top_items[1]} led sales.",
            "notes": f"{season.capitalize()} quarter. {narrative_desc}",
        }


def generate_quarterly_reports(branch_ids: list[str] | None = None):
    with open(DATA_DIR / "branches.json") as f:
        branches = json.load(f)
    if branch_ids:
        branches = [b for b in branches if b["id"] in branch_ids]
        print(f"  Filtering to {len(branches)} branches: {branch_ids}")
    with open(DATA_DIR / "staff.json") as f:
        all_staff = json.load(f)
    with open(DATA_DIR / "branch_narratives.json") as f:
        narratives = json.load(f)

    client = anthropic.Anthropic()

    # Index staff by branch
    staff_by_branch: dict[str, list[dict]] = {}
    for s in all_staff:
        bid = s["branch_id"]
        staff_by_branch.setdefault(bid, []).append(s)

    # Manager lookup
    managers: dict[str, dict] = {}
    for s in all_staff:
        if s["role"] == "Manager":
            managers[s["branch_id"]] = s

    reports = []
    total_llm_calls = 0

    for branch in branches:
        bid = branch["id"]
        manager = managers.get(bid)
        if not manager:
            continue

        staff = staff_by_branch.get(bid, [])
        narrative = narratives.get(bid, {})
        narrative_id = narrative.get("narrative_id", "steady_boring")
        tier = assign_performance_tier(bid)
        is_top_city = branch["city"] in TOP_CITIES
        size_mult = SIZE_MULT.get(branch["size"], 1.0)

        opened = datetime.strptime(branch["opened_date"], "%Y-%m-%d")
        closed = None
        if branch.get("closed_date"):
            closed = datetime.strptime(branch["closed_date"], "%Y-%m-%d")

        branch_reports = []
        for period, q_start, q_end, sub_base in QUARTERS:
            # Skip if branch wasn't open during this quarter
            if opened > q_end:
                continue
            if closed and closed < q_start:
                continue

            # Partial quarter if branch opened mid-quarter
            partial_factor = 1.0
            if opened > q_start:
                days_in_q = (q_end - q_start).days
                days_active = (q_end - opened).days
                partial_factor = max(0.1, days_active / days_in_q)

            # Partial quarter if branch closed mid-quarter
            if closed and closed < q_end:
                days_in_q = (q_end - q_start).days
                days_active = (closed - q_start).days
                partial_factor = min(partial_factor, max(0.1, days_active / days_in_q))

            qnum = get_quarter_num(period)
            year = int(period.split("-")[1])
            seed = f"{bid}-{period}"

            # ---- Revenue calculation ----
            if is_top_city:
                monthly_base = jitter(200_000, 0.12, f"rev-{seed}")
            else:
                monthly_base = jitter(115_000, 0.04, f"rev-{seed}")

            seasonal = SEASONAL_MULT[qnum]
            traffic_bonus = 1.08 if narrative_id in NARRATIVE_HIGH_TRAFFIC else 1.0
            tier_mult = {"super": 1.25, "average": 1.0, "under": 0.78}[tier]
            yoy_growth = 1 + 0.04 * (year - 2023)

            quarterly_revenue = (
                monthly_base * 3 * size_mult * seasonal
                * traffic_bonus * tier_mult * yoy_growth * partial_factor
            )
            monthly_effective = quarterly_revenue / 3
            if monthly_effective > 320_000:
                quarterly_revenue = 320_000 * 3
            quarterly_revenue = round(quarterly_revenue, 2)

            # ---- Transactions ----
            avg_ticket = jitter(7.50, 0.10, f"ticket-{seed}")
            if is_top_city:
                avg_ticket = jitter(8.80, 0.08, f"ticket-{seed}")
            avg_ticket = round(avg_ticket, 2)
            transactions = int(quarterly_revenue / avg_ticket)

            # ---- Labor ----
            active_staff_count = sum(
                1 for s in staff
                if s["status"] == "active"
                or (
                    s.get("end_date")
                    and datetime.strptime(s["end_date"], "%Y-%m-%d") > q_start
                )
            )
            employee_count = max(2, active_staff_count)

            labor_hours = int(employee_count * 520 * partial_factor)
            labor_cost_pct = jitter(31.0, 0.08, f"labor-{seed}")
            if tier == "under":
                labor_cost_pct *= 1.12
            elif tier == "super":
                labor_cost_pct *= 0.92
            labor_cost_pct = round(min(45.0, max(22.0, labor_cost_pct)), 1)

            turnover_this_q = [
                s for s in staff
                if s.get("end_date")
                and q_start <= datetime.strptime(s["end_date"], "%Y-%m-%d") <= q_end
            ]
            turnover_count = len(turnover_this_q)

            # ---- Inventory ----
            waste_pct = jitter(3.8, 0.15, f"waste-{seed}")
            if qnum == 3:
                waste_pct *= 1.15
            if tier == "under":
                waste_pct *= 1.25
            waste_pct = round(min(9.0, max(1.5, waste_pct)), 1)

            pool = TOP_SELLING_ITEMS_POOL[qnum]
            rng = random.Random(deterministic_hash(f"items-{seed}") * 10000)
            top_items = rng.sample(pool, 5)

            # ---- Customer satisfaction ----
            base_sat = 4.1
            if tier == "super":
                base_sat = 4.5
            elif tier == "under":
                base_sat = 3.4
            base_sat += NARRATIVE_SATISFACTION_BONUS.get(narrative_id, 0)
            base_sat += NARRATIVE_SATISFACTION_PENALTY.get(narrative_id, 0)
            if turnover_count >= 2:
                base_sat -= 0.2
            satisfaction = jitter(base_sat, 0.05, f"sat-{seed}")
            satisfaction = round(min(5.0, max(1.0, satisfaction)), 1)

            # ---- Equipment issues ----
            eq_range = NARRATIVE_EQUIPMENT_ISSUES.get(narrative_id, (0, 2))
            rng2 = random.Random(deterministic_hash(f"equip-{seed}") * 10000)
            equipment_issues = rng2.randint(eq_range[0], eq_range[1])
            if qnum in (1, 4):
                equipment_issues += rng2.randint(0, 1)

            # ---- LLM-generated narratives ----
            total_llm_calls += 1
            narr = generate_narratives_with_llm(
                client, branch, manager, narrative, period, qnum, tier,
                quarterly_revenue, labor_cost_pct, waste_pct, top_items,
                equipment_issues, turnover_this_q, employee_count, satisfaction,
            )

            # ---- Submission timestamp ----
            offset_days = int(deterministic_hash(f"submit-{seed}") * 7) - 3
            submitted_at = sub_base + timedelta(days=offset_days)
            hour = 8 + int(deterministic_hash(f"hour-{seed}") * 10)
            minute = int(deterministic_hash(f"min-{seed}") * 60)
            submitted_at = submitted_at.replace(hour=hour, minute=minute, second=0)

            report = {
                "id": f"{period.lower()}-{bid}",
                "report_type": "quarterly",
                "branch_id": bid,
                "branch_name": branch["name"],
                "period": period,
                "start_date": q_start.strftime("%Y-%m-%d"),
                "end_date": q_end.strftime("%Y-%m-%d"),
                "submitted_by": manager["email"],
                "submitted_at": submitted_at.strftime("%Y-%m-%dT%H:%M:%SZ"),
                "revenue": quarterly_revenue,
                "transactions": transactions,
                "avg_ticket": avg_ticket,
                "labor_hours": labor_hours,
                "labor_cost_pct": labor_cost_pct,
                "labor_manager_narrative": narr.get("labor_manager_narrative", ""),
                "inventory_waste_pct": waste_pct,
                "top_selling_items": top_items,
                "inventory_manager_narrative": narr.get("inventory_manager_narrative", ""),
                "customer_satisfaction": satisfaction,
                "employee_count": employee_count,
                "turnover_count": turnover_count,
                "equipment_issues": equipment_issues,
                "notes": narr.get("notes", ""),
            }
            branch_reports.append(report)
            save_report_to_file(report, submitted_at)

            if total_llm_calls % 50 == 0:
                print(f"  Progress: {total_llm_calls} reports generated...")

        if branch_reports:
            print(f"  {branch['name']}: {len(branch_reports)} quarters")
        reports.extend(branch_reports)

    print(f"\n  Total LLM calls: {total_llm_calls}")
    return reports


FINANCIAL_REPORTS_DIR = DATA_DIR / "financial-reports"


def save_report_to_file(report: dict, submitted_at: datetime) -> str:
    """Save a QBR to data/generated/financial-reports/<branch-id>/<year>/<month>/fin-report-<period>.txt"""
    bid = report["branch_id"]
    period = report["period"]
    year = period.split("-")[1]  # e.g. "2025"

    dir_path = FINANCIAL_REPORTS_DIR / bid / year
    dir_path.mkdir(parents=True, exist_ok=True)

    file_path = dir_path / f"fin-report-{period}.json"
    with open(file_path, "w", encoding="utf-8") as f:
        json.dump(report, f, indent=2)
    return str(file_path)


def main():
    branch_ids = [a for a in sys.argv[1:] if not a.startswith("--")] or None
    print("Generating quarterly reports (with LLM narratives)...")

    out_path = DATA_DIR / "quarterly_reports.json"
    reports = generate_quarterly_reports(branch_ids=branch_ids)
    print(f"  Generated {len(reports)} quarterly reports")

    # Save JSON
    with open(out_path, "w") as f:
        json.dump(reports, f, indent=2)
    print(f"  Saved to {out_path}")

    # Save index for file references
    index = []
    for r in reports:
        q_year = r["period"].split("-")[1]
        file_path = f"data/generated/financial-reports/{r['branch_id']}/{q_year}/fin-report-{r['period']}.json"
        index.append({
            "id": r["id"],
            "branch_id": r["branch_id"],
            "period": r["period"],
            "submitted_at": r["submitted_at"],
            "file_path": file_path,
        })
    index_path = FINANCIAL_REPORTS_DIR / "index.json"
    index_path.parent.mkdir(parents=True, exist_ok=True)
    with open(index_path, "w") as f:
        json.dump(index, f, indent=2)
    print(f"  Index saved to {index_path}")

    # Stats
    periods = Counter(r["period"] for r in reports)
    print("\nReports by quarter:")
    for period, count in sorted(periods.items()):
        print(f"  {period}: {count}")

    tiers = Counter(assign_performance_tier(b_id) for b_id in {r["branch_id"] for r in reports})
    print(f"\nPerformance tiers: {dict(tiers)}")

    revenues = [r["revenue"] for r in reports]
    monthly_revs = [r["revenue"] / 3 for r in reports]
    print(f"\nRevenue stats (quarterly):")
    print(f"  Min: ${min(revenues):,.0f}  Max: ${max(revenues):,.0f}")
    print(f"  Avg: ${sum(revenues)/len(revenues):,.0f}")
    print(f"\nMonthly equivalent:")
    print(f"  Min: ${min(monthly_revs):,.0f}  Max: ${max(monthly_revs):,.0f}")
    print(f"  Avg: ${sum(monthly_revs)/len(monthly_revs):,.0f}")

    # Sample
    print("\n" + "=" * 60)
    print("SAMPLE REPORT:")
    print("=" * 60)
    sample = random.choice(reports)
    for k, v in sample.items():
        print(f"  {k}: {v}")


if __name__ == "__main__":
    main()
